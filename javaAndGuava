java 平台平台： java 语言，JVM ，类库。
java 源代码， 字节码， JVM解释执行
一次编码，多处执行

不同与c++
  1. 内存管理
  2. 反射
  3. 完全的面向对象
学习重点：
  Git
  Maven
    项目管理工具， 类是与 make 工具
  Shell , vim , emacs
  web 开发
    Servlet规范
    HTTP 协议
  第三方类库：
    Guava, Apache Commons
  公司使用的框架：
    Spring,
    Mysql, PostgreSql, Mybais(ORM)
    Dubbo(系统通信,运维方便)
    日志： Slf4j+logback
  QMQ：
    消息队列，中间件
  Qscahedule
    任务调度中心
  Qconfig
    统一配置中心


基础数据类型：
  String , StringBuild 的源码，
  8 数据类型
从下面几个方面介绍 数据类型
  box & unbox 
  interger 中的缓存
  数值比较和溢出问题
  NPE 问题 null point error
  溢出：
    long millisOfYear = 5000 * 3000 * 44 * 123 ;  -> 溢出 
    long millisOfYear = 5000L * 3000 * 44 * 123 ;  -> 正常
  NPE：
    Interger a=null;
    Interger a=a.Intvalue(); -> 错误
  精度的丢失：  
    println(new BigDecimal(0.58))   ->    0.579999
    
    正确的构造方式：
       BigDecimal a = new BigDecimal.valueof(0.580);   ->  回去掉最后的 0
       BigDecimal b = new BigDecimal("0.580")
       数值比较：
        a.equals(b)   ->  false
        a.compareTo(b)  ->  true
        指定算法精度：
          a.divide(b, MathContent.DECIMAL64);
          
  StringBuilder
      StringBuilder append：
          StringBuild 与 StringBuffer 继承 AbstratStringBuilder ,
                                      impliments java.io.Serializable;
                                      StringBuffer 中 包含 syschronized,多线程安全
                                      StringBuilder 没有加锁，效率更高。
          
      StringBuilder 扩容 ：
          在 append 调用自动扩容的代码，函数在AbstratStringBuilder 中的 ensureCapacityInternal();
          
      String guava 提供
          String.isNllorEmpty()
          String.nullToeEpty()
          commomSuffix(a,b);
          commomPreffix(a,b);
          String.paddStart(a, 5, '*');
          String.paddEnd(a, 5, '*');
     Ints:  guava 提供
        补充Interger 和 Arrays  中对 int 类型的操作;
        常用方法：
          Ints.compare(a,b);
          asList;
          Ints.contains(arrayA,1);
          max; min;
          
          JDK:
            Arrays.asList();  ->  返回 List, 元素是数组List<int []>。。
          guavas:
            Ints.asList();    ->  返回List, 元素是 List<Int>, 不可变！！！， 没有add方法
      Joiner: guava 提供
          List<Integer> a=List.newArrayList(1,2,5);
          logger.info("join result {}", Joiner.on("|").join(a));  - >  a 中不能有null
          logger.info("join result {}", Joiner.on("|").skipNull().join(a));  - >  a 中有null
          logger.info("join result {}", Joiner.on("|").useForNull("7").join(a));  - >  a 中有null
          
          使用Joiner 链接一个 Map 
            Map<String, String> para = Maps.newHashMap();
            para.put("name", "qiongweiren");
            para.put("id", "0");
            String queryString = Joiner.on("&").withKeyValueSeparator("=").join(para);
            
       Splitter: guava 提供
          用于将字符串按照某个 separator 分割成List 或者 Map; Immutable/ThreadSafe
          Splitter 和 MapSplitter 的基本用法;
          String string = ", a ,b ,";
          String regexSplit = string.split(",")                                ->    输出是[, a ,b ]
          List<String> guavaSplit =   Splitter.on(",").splitToList(string)   ->    输出是[, a ,b ,]
          List<String> guavaSplit =   Splitter.on(",").trimResult().splitToList(string)   ->    输出是[,a,b,]
          List<String> guavaSplit =   Splitter.on(",").trimResult().omitEmptyString().splitToList(string)   ->    输出是[a,b]
          
          String querystring = "a=1&b=2";
          Map<Srring, String> split = Splitter.on("&").withKeyVauleSeparator("=").split(queryString);
          
      Objects:guava 提供
          操作 Object 的辅助类
              equls:
                  JDK ：
                    String a = null;
                    String b = null;
                    a.equals(b)      ->  a 为 null 时 会抛出错误，b 没影响。
                  guava:
                    Objects.equal(a,b) -> 不会 
              hashCode
                  Object.hashCode(1,2);
              toStringHelper
              firstNonNull
              
   
        
       CharMatcher: guava提供
          CharMatcher charmatcher = CharMatcher.anyOf("abcd"); ->  'a', 'b','c','d';
          String newstr  = charmatcher.reomovefrom(str);
          String newstr  = charmatcher.retainfrom(str);
          CharMatcher charmatcher = CharMatcher.anyOf("abcd").or(CharMatcher.is('2'));
          
          Splitter.on(",").trimResult(CharMatcher.is('a')).splitToList(str)

        Optional:
            1. 作为方法的返回值，
              1. String process();
              2. Optional<String> process();   ->  调用方明确知道返回值可能不存在
                    return a>0 ? Optional.<String>absent() :  Optional.of("xxx");
                    result.isPresent();
            2. 作为默认值的设置
              Integer a = Optional.fromNullable(b).or(0);
            

        Fucntion: guava 
            Function 定义的函数 ->  接受一个输入参数，转换为另一个结果。
              Function<Interger,String> iotoString = new Function<Interger, String>()
              {
                Public String apply(Interger input)
                {}
              }
              
              String x = iotoString.apply(5);     ->    
              
            Predicate 定义的函数 p_func ->  判断参数是否满足一定的条件, 
              Predicate<Interger> greaterThan5 = new Predicate<Interger>(){
                 public boolean apply(Interger input)              
              }
              
              out.println(greaterThan5(10));
              
              
      String 的 intern 
      String 的 Interners  ????
      
      
 Joda-Time
      见工程测试代码
 
 异常处理：
    如何处理程序中出现的错误或者异常
    1. 返回值方式处理异常
    2. 异常机制
        1. Throwable
          1.1 Error     ->  不用catch 这种
          1.2 Exception
            1.2.1 RuntimeException    ->    非受检查异常，可以不catch.
            1.2.x ...                 ->  受检查异常 -> catch 或者 throws声明
    
    3. 异常方法：
        1. Exception.getMessage
        2. Exception.getCause
        3. Exception.printStackTrace  -->  不奥要执行这句
        4. Exception.getStackTrace , 需要统计堆栈数据
    4. 异常处理：
        捕获异常：
          try{}catch(){}finally{}
          
    5. guavas 异常处理：
        工具类：Throwables:
            getCausalChain  ->  异常链
            getRootCause    -> 得到最原始的异常，最早的Throw点
            propagate       ->  将 Exception 包装成 RuntimeException  或则和error,简化异常处理
            getStackTraceAsString    ->   以String 的方式返回错误的信息
            
    
日志：
    slf4j  
            面向接口，只提供日志系统的接口
            实现层 调用原生实现接口 或者通过适配层调用其他其他日志库的方法来实现
            能适配多种不同的日志框架，实现日志的统一配置和管理
    lockback:
            slf4j 接口的原生实现，非通过适配层
            logback: Logger, Appender, Layout
              1. LOgger         -> 产生日志事件，可配置级别
              2. Appender       ->  将日志事件代理到具体的日志记录组建
                    1. DBAppender ->  日志事件记录到数据库
                    2. FileAppender    ->  日志事件记录到文件中
                    3. RollingFIlAppender -> 将日志按照一定的策略进行分割存储
                    
              Layout             ->    将日志时间格式化为具体的日志记录：
                    1. HTMLLayout    ->  输出为HTML
                    2. PattrernLayout   ->  根据配置的Pattern 格式化日志事件
                    
     日志级别：
          trace,< debug< info< warn< error
          
          配置级别的方法：
            <logger name="hotel.order.log" level="debug">   ->  包名
                  <append-ref ref="file" />
            </logger>
              
     使用占位符代替字符串拼接
     
      Logger.error("error occurred reason{}. stack{}", e.getMessenge(), e);   
            ->  错误，最后 e 是Throwable,所有 Throwable 会在占位父判断完之后进行输出。不能够放到占位符里面
            
代码规范：
  类名： 形容词或者 形容词
  方法名 ： 动词
  使用恰当的词标识方法背后的动作
  
  接口：
    通信协议，意义要明确
    职责单一，接口数据的组合尽量放到调用方完成
    接口实现需要严格的遵循接口规范,尽量不要做隐形约定(默认值)
    返回容器的地方不要返回null, 返回空的容器
    RPC接口返回java原生容器，不免使用第三方库提供的容器
  注释：
    javadoc 格式编写的注释
    接口的注释，参数，返回值，调用频率限制，使用说明
    
 
 
 Jdk collentions:
 
    继承于 collection  ->  定义接口
        list  ->   定义接口
          arraylist   ->  实现
          linklist    ->  
        set     -->  定义接口
          hashset 
          lindedset
          treeset
          
    map:      ->   定义接口
      haskmap
      linedmap
      treemap
    
    
      
            
    
    
            
    
  
  
  
  
  
  
  
  
  
  
  
    
