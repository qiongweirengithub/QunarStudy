异常被吞; util.log("err",e)
\n :  换行符号 等等，要根据系统变量来编码 

try  catch  finally

Comparable 使用不同的排序方式
Comparator


time 记录格式应该保持原有形式，需要指向专用操作的时候再转变形式。


System.out 的缺点： 
    out.println 流程; 
      1. syschronized(this);      ->>     多线程下同步会造成输出阻塞，造成性能下降。
      2. print();
      3. newline();
    替换为日志输出方式。
      Util.log("");

缓存与缓冲：
    
      
流关闭注意判断流是否存在。

logger.info("x {} y{}", "t1", "t2");   ->>    "t1" 到第一个{}, 

Util类 不应该实例化， 一般是一些静态方法，可以通过声明为 abstract 防止对 Util 类实例化。

注意代码的复用;
   代码抽象:
        

线程安全：
    1. 资源是否是共享的。内部变量就是线程安全的。
    2. 共享的变量有写操作，会有线程不安全的隐患
    加锁： 
        乐观锁： 先执行，出现问题再处理。
        悲观锁： 必须排队。
        加锁力度要小，提高效率。
        同步控制  ->   

内容的呈现：
    数据的结构 要与 数据的呈现方式 两个功能 隔离开
    
    
善用 接口设计 实现代码的复用：
    


静态内部类：
    类内部的逻辑是否需要外界访问，
guava中很多类采用工厂方法新建对象
    屏蔽了实现细节，简化构造的流程

WeakReference<Integer> weak = new WeakReference<Integer>(100);    ->>   1000
System.gc();
Thread.sleep(1000L);
out.println(weak.get());


领读部分代码：
    Joiner , Optional, HashMap, 
    HashMap: 
        扩容如何实现，扩容对性能的影响
    guava:
        
    优秀框架：
        spring IOC 存储代码
        guava 代码
        jdk 并发原发实现
        lockback 日志框架
        apache commends 库
        PC部 : 
   
Map: 遍历方法：
    entry set;
    key set;
    value set;
    



java file.java       ->    file.class
javap - verbose file    ->     


中文乱码问题：
      指定博客：  http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html
        
   

obj = Class.forname()    //----------------利用反射获得的类。
method.invoke(obj, dateFormat.parse(value));

Map<Class, property> classMap = new weakMap()

xml解析
    ：SAXParse;
    : Dom 
    
接口，类，抽象，注入，反射，


第二期：5-10, 20 作业题目


根据 行为 针对的内容 确定 方法是否应为 static
    购物车内部计算和 订单添加和删除 
访问修饰符：
    private,  protect, public,

远程资源的读取：
    异步：读取资源的类型
    同步：阻塞读取
guava 异步编程:
    filter， listen ,


内部类
    

        
        
        
        










